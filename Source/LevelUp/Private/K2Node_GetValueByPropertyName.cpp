// Copyright Epic Games, Inc. All Rights Reserved.

#include "K2Node_GetValueByPropertyName.h"

#include "EdGraphSchema_K2.h"
#include "EditorCategoryUtils.h"

#include "EdGraphUtilities.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "K2Node_PureAssignmentStatement.h"
#include "K2Node_TemporaryVariable.h"

#include "KismetCompiler.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "LevelUpLibrary.h"
#include "K2Node_CallFunction.h"

#include "UI/SGraphPinValueByProperty.h"

#define LOCTEXT_NAMESPACE "K2Node_GetValueByPropertyName"

static const FName TargetPinName(TEXT("Target"));
static const FName PropertyNamePinName(TEXT("PropertyName"));
static const FName OutputResultPinName(TEXT("bSuccess"));
static const FName OutputValuePinName(TEXT("Value"));

void UK2Node_GetValueByPropertyName::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	UEdGraphNode::FCreatePinParams PinParams;
	PinParams.bIsReference = true;

	UEdGraphPin* TargetPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, UObject::StaticClass(), TargetPinName, PinParams);
	SetPinToolTip(*TargetPin, LOCTEXT("TargetPinDescription", "The Object to get the variable from."));

	UEdGraphPin* PropertyNamePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, PropertyNamePinName);
	SetPinToolTip(*PropertyNamePin, LOCTEXT("PropertyNamePinDescription", "The name of the variable."));

    UEdGraphPin* SuccessPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, OutputResultPinName);
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(SuccessPin);

	UEdGraphPin* ResultPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, OutputValuePinName);
	ResultPin->PinFriendlyName = LOCTEXT("GetValueByPropertyName Output", "Value");
	SetPinToolTip(*ResultPin, LOCTEXT("ResultPinDescription", "The returned Value, if property found"));

	Super::AllocateDefaultPins();

}

void UK2Node_GetValueByPropertyName::PostReconstructNode()
{
	Super::PostReconstructNode();
	RefreshOutValuePinType(true);
}

void UK2Node_GetValueByPropertyName::PinDefaultValueChanged(UEdGraphPin* Pin)
{
	OnTargetOrNamePinChanged(Pin);
}

FText UK2Node_GetValueByPropertyName::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("GetValueByPropertyName_Title", "Get Value By Property Name");
}

FText UK2Node_GetValueByPropertyName::GetTooltipText() const
{
	return LOCTEXT("GetValueByPropertyName_Tooltip", "Get value from target by property name");
}

void UK2Node_GetValueByPropertyName::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);
	if (Pin && Pin->LinkedTo.Num() == 0)
	{
		OnTargetOrNamePinChanged(Pin);
	}
}

bool UK2Node_GetValueByPropertyName::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin, FString& OutReason) const
{
    if (MyPin == GetTargetPin())
    {
        if (OtherPin->PinType.IsContainer())
        {
            OutReason = FText::FromString("You cannot use containers of objects").ToString();
			return true;
        }
		else if (OtherPin->PinType.PinCategory != UEdGraphSchema_K2::PC_Object)
        {
			OutReason = FText::FromString("You can only use objects").ToString();
			return true;
        }
    }

    return false;
}

FText UK2Node_GetValueByPropertyName::GetMenuCategory() const
{
	return FEditorCategoryUtils::GetCommonCategory(FCommonEditorCategory::Utilities);
}

void UK2Node_GetValueByPropertyName::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);
	UClass* Action = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(Action))
	{
		UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
		check(Spawner != nullptr);
		ActionRegistrar.AddBlueprintAction(Action, Spawner);
	}
}

void UK2Node_GetValueByPropertyName::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

    if (!GetTarget())
    {
        CompilerContext.MessageLog.Error(*FText::FromString("GetValueByPropertyName K2Node must have a target object").ToString(), this);
        BreakAllNodeLinks();
        return;
    }

	UFunction* Function = ULevelUpLibrary::StaticClass()->FindFunctionByName("GetValueByPropertyName");
	if (Function == NULL)
    {
        CompilerContext.MessageLog.Error(*FText::FromString("The function has not been found").ToString(), this);
        return;
    }

    UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	CallFunction->SetFromFunction(Function);
    CallFunction->AllocateDefaultPins();
    CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallFunction, this);

	CompilerContext.MovePinLinksToIntermediate(*GetTargetPin(), *CallFunction->FindPinChecked(TEXT("Target")));
    CompilerContext.MovePinLinksToIntermediate(*GetPropertyNamePin(), *CallFunction->FindPinChecked(TEXT("PropertyName")));

    UEdGraphPin* OriginalOutValuePin = GetReturnValuePin();
    UEdGraphPin* FunctionOutValuePin = CallFunction->FindPinChecked(TEXT("OutValue"));
    FunctionOutValuePin->PinType = OriginalOutValuePin->PinType;
    FunctionOutValuePin->PinType.PinSubCategoryObject = OriginalOutValuePin->PinType.PinSubCategoryObject;
    CompilerContext.MovePinLinksToIntermediate(*OriginalOutValuePin, *FunctionOutValuePin);

    CompilerContext.MovePinLinksToIntermediate(*GetSuccessPin(), *CallFunction->GetReturnValuePin());
    CompilerContext.MovePinLinksToIntermediate(*GetExecPin(), *CallFunction->GetExecPin());
    CompilerContext.MovePinLinksToIntermediate(*GetThenPin(), *CallFunction->GetThenPin());

    BreakAllNodeLinks();
}

void UK2Node_GetValueByPropertyName::SetPropertyNameGraphPin(TSharedPtr<SGraphPinValueByProperty> GraphPin)
{
	PropertyNameGraphPin = GraphPin;
}

FSlateIcon UK2Node_GetValueByPropertyName::GetIconAndTint(FLinearColor& OutColor) const
{
	OutColor = GetNodeTitleColor();
	static FSlateIcon Icon(FAppStyle::GetAppStyleSetName(), "Kismet.AllClasses.FunctionIcon");
	return Icon;
}

void UK2Node_GetValueByPropertyName::SetPinToolTip(UEdGraphPin& MutatablePin, const FText& PinDescription) const
{
	MutatablePin.PinToolTip = UEdGraphSchema_K2::TypeToText(MutatablePin.PinType).ToString();

	UEdGraphSchema_K2 const* const K2Schema = Cast<const UEdGraphSchema_K2>(GetSchema());
	if (K2Schema != nullptr)
	{
		MutatablePin.PinToolTip += TEXT(" ");
		MutatablePin.PinToolTip += K2Schema->GetPinDisplayName(&MutatablePin).ToString();
	}

	MutatablePin.PinToolTip += FString(TEXT("\n")) + PinDescription.ToString();
}

FEdGraphPinType UK2Node_GetValueByPropertyName::GetObjectPropertyPinType(const UObject* TargetObject) const
{
	FEdGraphPinType PinType;
	PinType.ResetToDefaults();
	PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;

	const UClass* TargetClass = Cast<const UClass>(TargetObject);
	FName PropertyName = GetPropertyName();

	if (TargetClass && !PropertyName.IsNone())
	{
		if (const FProperty* ResultProperty = TargetClass->FindPropertyByName(PropertyName))
		{
			FName PropertyCPPType = *ResultProperty->GetCPPType();

			if (ResultProperty->IsA<FBoolProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_Boolean;
			}
			else if (ResultProperty->IsA<FNumericProperty>())
			{
				const FNumericProperty* NumericProperty = CastField<const FNumericProperty>(ResultProperty);
				if (const FByteProperty* ByteProperty = CastField<const FByteProperty>(NumericProperty))
				{
					PinType.PinCategory = UEdGraphSchema_K2::PC_Byte;
				}
				else if (NumericProperty->IsInteger())
				{
					PinType.PinCategory = UEdGraphSchema_K2::PC_Int;
				}
				else if (PropertyCPPType == TEXT("float"))
				{
					PinType.PinCategory = UEdGraphSchema_K2::PC_Real;
					PinType.PinSubCategory = UEdGraphSchema_K2::PC_Float;
				}
				else if (PropertyCPPType == TEXT("double"))
				{
					PinType.PinCategory = UEdGraphSchema_K2::PC_Real;
					PinType.PinSubCategory = UEdGraphSchema_K2::PC_Double;
				}
			}
			else if (ResultProperty->IsA<FNameProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_Name;
			}
			else if (ResultProperty->IsA<FStrProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_String;
			}
			else if (ResultProperty->IsA<FTextProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_Text;
			}
			else if (ResultProperty->IsA<FStructProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
				PinType.PinSubCategoryObject = CastField<const FStructProperty>(ResultProperty)->Struct;
			}
			else if (ResultProperty->IsA<FClassProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_Class;
				PinType.PinSubCategoryObject = CastField<const FClassProperty>(ResultProperty)->MetaClass;
			}
			else if (ResultProperty->IsA<FObjectProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_Object;
				PinType.PinSubCategoryObject = UObject::StaticClass();
			}
			else if (ResultProperty->IsA<FEnumProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_Byte;
				PinType.PinSubCategoryObject = CastField<const FEnumProperty>(ResultProperty)->GetEnum();
			}
			else if (ResultProperty->IsA<FDelegateProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_Delegate;
				PinType.PinSubCategoryObject = CastField<const FDelegateProperty>(ResultProperty)->SignatureFunction;
			}
			else if (ResultProperty->IsA<FMulticastDelegateProperty>())
			{
				PinType.PinCategory = UEdGraphSchema_K2::PC_MCDelegate;
				PinType.PinSubCategoryObject = CastField<const FMulticastDelegateProperty>(ResultProperty)->SignatureFunction;
			}
		}
	}

	return PinType;
}

void UK2Node_GetValueByPropertyName::OnTargetOrNamePinChanged(UEdGraphPin* Pin)
{
	if (Pin)
	{
		bool bIsObjectPinChanged = Pin->PinName == TargetPinName;
		bool bIsPropertyNamePinChanged = Pin->PinName == PropertyNamePinName;
		if (bIsObjectPinChanged || bIsPropertyNamePinChanged)
		{
			RefreshOutValuePinType(bIsObjectPinChanged);
		}
	}
}

void UK2Node_GetValueByPropertyName::RefreshOutValuePinType(bool bRefreshGraphPinSlate)
{
	const UObject* Target = GetTarget();

	if (bRefreshGraphPinSlate && PropertyNameGraphPin.IsValid())
	{
		PropertyNameGraphPin->UpdateTargetObject(Target);
	}

    UEdGraphPin* OutValuePin = GetReturnValuePin();

    if (OutValuePin)
    {
		FEdGraphPinType NewPinType = GetObjectPropertyPinType(Target);

        if (OutValuePin->SubPins.Num() > 0)
        {
            GetSchema()->RecombinePin(OutValuePin);
        }

        OutValuePin->PinType = NewPinType;
    }
}

UObject* UK2Node_GetValueByPropertyName::GetTarget() const
{
	UEdGraphPin* TargetPin = GetTargetPin();
	UObject* Target = nullptr;

	if (TargetPin)
	{
		if (TargetPin->LinkedTo.Num() > 0)
		{
			const UEdGraphPin* LinkedPin = TargetPin->LinkedTo[0];
			const FEdGraphPinType& LinkedPinType = LinkedPin->PinType;
			if (LinkedPinType.PinCategory == UEdGraphSchema_K2::PC_Object)
			{
				if (LinkedPinType.PinSubCategoryObject.IsValid())
				{
					Target = LinkedPinType.PinSubCategoryObject.Get();
				}
				else if (LinkedPinType.PinSubCategory == UEdGraphSchema_K2::PSC_Self)
				{
					if (UBlueprint* Blueprint = GetBlueprint())
					{
						Target = Blueprint->GeneratedClass;
					}
				}
			}
			else if (IsValid(LinkedPin->DefaultObject))
			{
				Target = LinkedPin->DefaultObject;
			}
		}
	}

	return Target;
}

FName UK2Node_GetValueByPropertyName::GetPropertyName() const
{
	FName PropertyName = NAME_None;

	UEdGraphPin* PropertyNamePin = GetPropertyNamePin();

	if (PropertyNamePin)
	{
		if (PropertyNamePin->LinkedTo.Num() == 0)
		{
			PropertyName = FName(PropertyNamePin->DefaultValue);
		}
		else
		{
			UEdGraphPin* LinkedPin = PropertyNamePin->LinkedTo[0];
			PropertyName = FName(LinkedPin->DefaultValue);
		}
	}

	return PropertyName;
}

UEdGraphPin* UK2Node_GetValueByPropertyName::GetThenPin() const
{
	UEdGraphPin* Pin = FindPinChecked(UEdGraphSchema_K2::PN_Then);
	check(Pin == NULL || Pin->Direction == EGPD_Output);
	return Pin;
}

UEdGraphPin* UK2Node_GetValueByPropertyName::GetTargetPin() const
{
	UEdGraphPin* Pin = FindPin(TargetPinName);
	check(Pin == NULL || Pin->Direction == EGPD_Input);
	return Pin;
}

UEdGraphPin* UK2Node_GetValueByPropertyName::GetPropertyNamePin() const
{
	UEdGraphPin* Pin = FindPin(PropertyNamePinName);
	check(Pin == NULL || Pin->Direction == EGPD_Input);
	return Pin;
}

UEdGraphPin* UK2Node_GetValueByPropertyName::GetSuccessPin() const
{
	UEdGraphPin* Pin = FindPin(OutputResultPinName);
	check(Pin == NULL || Pin->Direction == EGPD_Output);
	return Pin;
}

UEdGraphPin* UK2Node_GetValueByPropertyName::GetReturnValuePin() const
{
	UEdGraphPin* Pin = FindPinChecked(OutputValuePinName);
	check(Pin == NULL || Pin->Direction == EGPD_Output);
	return Pin;
}

#undef LOCTEXT_NAMESPACE